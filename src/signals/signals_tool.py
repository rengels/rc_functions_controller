#!/usr/bin/env python3

# this script will output signal_types.h header containing signal definitions
# rc function controller proc modules.
#
# example usage: signals_tool.py --header signal_types.h
#

import argparse
import datetime
import json
import pathlib


def output_h(defs_signals, out_file):
    """Outputs the signal types header containing SignalTypes enum into the out file."""

    def signal_type_line(signal):
        """Converts an entry in def_signals to a line for the header file

        :param signal: A signal structure from the def_signals.json file.
          A dict containing optional *name*, *index* and *description*.
        """
        ret = ""
        if "name" in signal:
            ret += "    " + signal["name"]
            if "index" in signal:
                ret += " = " + str(signal["index"]) + ","
            else:
                ret += ","

        if "description" in signal:
            if len(ret) == 0:  # just a description
                ret = "\n    // -- " + signal["description"]
        else:
            ret += (" " * (27 - len(ret))) + "///< " + str(signal["description"])
        return ret

    print(
        f"""/** Signal type definition.
 *
 * This file is auto generated by signals_tool.py
 * {str(datetime.date.today())}
 *
 * Do not modify.
 *
 * @file
 */

#ifndef _RC_SIGNAL_TYPESS_H_
#define _RC_SIGNAL_TYPESS_H_

#include <cstdint>

namespace rcSignals {{

/** This struct contains the indices into the *Signals* structure.
 *
 *  These signals represent the main communication bus throught the
 *  project.
 *  Every 20ms the signals are set to RCSIGNAL_INVALID and then
 *  filled via input and proc-modules.
 *
 */
enum class SignalType : uint8_t {{
{"\n".join([signal_type_line(signal) for signal in defs_signals])}
    ST_NUM                 ///< total amount of types.
}};

}} // namespace

#endif // _RC_SIGNAL_TYPESS_H_
""",
        file=out_file,
    )

# --- main code

parser = argparse.ArgumentParser(
    prog="signals_tool",
    description="Tool for creating header file with signal definitions.",
    epilog="Have fun",
)

parser.add_argument(
    "--signals",
    "-s",
    type=argparse.FileType("r"),
    help="Signals definition file",
    default=str(pathlib.Path(__file__).parent.parent / "config" / "signals_config.json"),
)
parser.add_argument(
    "--header",
    type=argparse.FileType("w"),
    help="Create .h file containing the signals definitions.",
)

args = parser.parse_args()

defs_signals = json.load(args.signals)

# create a mapping signal name vs index
signals_mapping = {}
index = 0
for signal in defs_signals:
    if "index" in signal:
        index = signal["index"]
    if "name" in signal:  # jump over descriptions
        signals_mapping[signal["name"]] = index
        index += 1

if args.header:
    output_h(defs_signals, args.header)
