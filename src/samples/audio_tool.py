#!/usr/bin/env python3

# This script will output code for the static samples list.
#
# example usage: audio_tool.py --audio sample_config.json --cpp samples.cpp
#

import argparse
import datetime
import pathlib
import json
import re


def output_cpp(defs_audio, out_file):
    """Outputs the code for the static audio list.
    """

    sample_symbols = []
    samples = []
    for audio in defs_audio:
        if "filename" in audio:
            symbol = re.sub(r"^.*\/", "", audio["filename"])
            symbol = symbol.replace(".", "_")
            sample_symbols.append(
                    f"extern const uint8_t _binary_{symbol}_start[];\n"
                    f"extern const uint8_t _binary_{symbol}_end[];\n"
                    )

            if "id" in audio:
                samples.append(
                        f"  SampleFile{{.id = {{'{audio["id"][0]}', '{audio["id"][1]}', '{audio["id"][2]}'}},\n"
                        f"    .content = std::span{{_binary_{symbol}_start,\n"
                        f"       static_cast<size_t>(_binary_{symbol}_end - _binary_{symbol}_start)}}\n"
                        f"  }}"
                        )

    print(
        f"""/** The static sample list.
 *
 * This file is auto generated by audio_tool.py
 * {str(datetime.date.today())}
 *
 * Do not modify.
 *
 * @file
 */

#include "sample.h"
#include <span>

using namespace rcSamples;

{''.join(sample_symbols)}

const SampleFile staticSamplesArray[]{{
{',\n'.join(samples)}
}};

std::span<const rcSamples::SampleFile> staticSamplesSpan(staticSamplesArray);

const std::span<const rcSamples::SampleFile>& rcSamples::getStaticSamples() {{
  return staticSamplesSpan;
}}

""",
        file=out_file,
    )

# --- main code

parser = argparse.ArgumentParser(
    prog="audio_tool",
    description="Tool for creating a file with all the static samples.",
)

parser.add_argument(
    "--audio",
    "-a",
    type=argparse.FileType("r"),
    help="Audio configuration file",
    default=str(pathlib.Path(__file__).parent.parent / "config" / "sample_config.json"),
)
parser.add_argument(
    "--cpp",
    "-c",
    type=argparse.FileType("w"),
    help="Create .cpp file for the audio list.",
)

args = parser.parse_args()
defs_audio = json.load(args.audio)

# ensure no duplicate IDs
ids = set()
for audio in defs_audio:
    if "id" in audio:
        if audio["id"] in ids:
            exit(f"Duplicate id {audio['id']} in audio {audio['name']}")
        ids.add(audio["id"])


if args.cpp:
    output_cpp(defs_audio, args.cpp)
