/** Serialization code for the proc classes.
 *
 * This file is auto generated by serialization_tool.py
 * 2025-06-01
 *
 * Do not modify.
 *
 * @file
 */

#include "proc_storage.h"
#include "proc.h"
#include "simple_byte_stream.h"
#include <cstdio>

#include "input_demo.h"
#ifdef ARDUINO
#include "input_adc.h"
#endif
#ifdef ARDUINO
#include "input_pin.h"
#endif
#ifdef ARDUINO
#include "input_pwm.h"
#endif
#ifdef ARDUINO
#include "input_ppm.h"
#endif
#ifdef ARDUINO
#include "input_sbus.h"
#endif
#ifdef ARDUINO
#include "input_srxl.h"
#endif
#ifdef ARDUINO
#include "output_audio.h"
#endif
#ifdef ARDUINO
#include "output_led.h"
#endif
#ifdef ARDUINO
#include "output_esc.h"
#endif
#ifdef ARDUINO
#include "output_pwm.h"
#endif
#include "proc_group.h"
#include "proc_auto.h"
#include "proc_combine.h"
#include "proc_cranking.h"
#include "proc_delay.h"
#include "proc_direction.h"
#include "proc_excavator.h"
#include "proc_expo.h"
#include "proc_fade.h"
#include "proc_indicator.h"
#include "proc_map.h"
#include "proc_misfire.h"
#include "proc_periodic.h"
#include "proc_power.h"
#include "proc_random.h"
#include "proc_sequence.h"
#include "proc_scenario.h"
#include "proc_switch.h"
#include "proc_threshold.h"
#include "proc_xenon.h"
#include "engine_reverse.h"
#include "engine_brake.h"
#include "engine_gear.h"
#include "engine_simple.h"
#include "audio_dynamic.h"
#include "audio_loop.h"
#include "audio_engine.h"
#include "audio_noise.h"
#include "audio_simple.h"
#include "audio_steam.h"

struct ProcId {
  char c1;
  char c2;
};

bool operator==(const ProcId& lhs, const ProcId& rhs) {
    return (lhs.c1 == rhs.c1) && (lhs.c2 == rhs.c2);
}

using namespace rcSignals;
using namespace rcProc;
using namespace rcInput;


// -- Input


namespace rcInput {

/** Serializes InputDemo to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const InputDemo& proc) {

    out << 'D' << 'E';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << static_cast<uint8_t>(proc.scriptType);

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes InputDemo from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    InputDemo& proc) {

    proc.scriptType = static_cast<InputDemo::DemoType>(in.read<uint8_t>());
    return in;
}

}
#ifdef ARDUINO

namespace rcInput {

/** Serializes InputAdc to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const InputAdc& proc) {

    out << 'A' << 'D';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.type;
    out << static_cast<int8_t>(proc.pin);

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes InputAdc from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    InputAdc& proc) {

    in >> proc.type;
    proc.pin = static_cast<gpio_num_t>(in.read<int8_t>());
    return in;
}

}
#endif // ARDUINO
#ifdef ARDUINO

namespace rcInput {

/** Serializes InputPin to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const InputPin& proc) {

    out << 'P' << 'I';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.types;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes InputPin from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    InputPin& proc) {

    in >> proc.types;
    return in;
}

}
#endif // ARDUINO
#ifdef ARDUINO

namespace rcInput {

/** Serializes InputPwm to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const InputPwm& proc) {

    out << 'P' << 'W';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.types;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes InputPwm from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    InputPwm& proc) {

    in >> proc.types;
    return in;
}

}
#endif // ARDUINO
#ifdef ARDUINO

namespace rcInput {

/** Serializes InputPpm to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const InputPpm& proc) {

    out << 'P' << 'P';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.types;
    out << proc.numInputs;
    out << static_cast<int8_t>(proc.pin);

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes InputPpm from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    InputPpm& proc) {

    in >> proc.types;
    in >> proc.numInputs;
    proc.pin = static_cast<gpio_num_t>(in.read<int8_t>());
    return in;
}

}
#endif // ARDUINO
#ifdef ARDUINO

namespace rcInput {

/** Serializes InputSbus to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const InputSbus& proc) {

    out << 'S' << 'B';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.types;
    out << proc.fast;
    out << proc.inverted;
    out << static_cast<int8_t>(proc.pin);

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes InputSbus from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    InputSbus& proc) {

    in >> proc.types;
    in >> proc.fast;
    in >> proc.inverted;
    proc.pin = static_cast<gpio_num_t>(in.read<int8_t>());
    return in;
}

}
#endif // ARDUINO
#ifdef ARDUINO

namespace rcInput {

/** Serializes InputSrxl to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const InputSrxl& proc) {

    out << 'S' << 'R';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.types;
    out << static_cast<int8_t>(proc.pin);

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes InputSrxl from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    InputSrxl& proc) {

    in >> proc.types;
    proc.pin = static_cast<gpio_num_t>(in.read<int8_t>());
    return in;
}

}
#endif // ARDUINO

// -- Output

#ifdef ARDUINO

namespace rcOutput {

/** Serializes OutputAudio to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const OutputAudio& proc) {

    out << 'O' << 'A';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later


    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes OutputAudio from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    OutputAudio& proc) {


    return in;
}

}
#endif // ARDUINO
#ifdef ARDUINO

namespace rcOutput {

/** Serializes OutputLed to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const OutputLed& proc) {

    out << 'O' << 'L';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.types;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes OutputLed from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    OutputLed& proc) {

    in >> proc.types;
    return in;
}

}
#endif // ARDUINO
#ifdef ARDUINO

namespace rcOutput {

/** Serializes OutputEsc to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const OutputEsc& proc) {

    out << 'O' << 'E';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.types;
    out << proc.deadZone;
    out << proc.freqTypes;
    out << proc.pins;
    out << proc.pins2;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes OutputEsc from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    OutputEsc& proc) {

    in >> proc.types;
    in >> proc.deadZone;
    in >> proc.freqTypes;
    in >> proc.pins;
    in >> proc.pins2;
    return in;
}

}
#endif // ARDUINO
#ifdef ARDUINO

namespace rcOutput {

/** Serializes OutputPwm to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const OutputPwm& proc) {

    out << 'O' << 'P';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.types;
    out << proc.pins;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes OutputPwm from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    OutputPwm& proc) {

    in >> proc.types;
    in >> proc.pins;
    return in;
}

}
#endif // ARDUINO

// -- General


namespace rcProc {

/** Serializes ProcGroup to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcGroup& proc) {

    out << 'G' << 'R';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.type;
    out << proc.numChilds;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcGroup from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcGroup& proc) {

    in >> proc.type;
    in >> proc.numChilds;
    return in;
}

}

namespace rcProc {

/** Serializes ProcAuto to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcAuto& proc) {

    out << 'A' << 'U';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later


    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcAuto from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcAuto& proc) {


    return in;
}

}

namespace rcProc {

/** Serializes ProcCombine to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcCombine& proc) {

    out << 'C' << 'O';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.inTypes;
    out << proc.outTypes;
    out << static_cast<uint8_t>(proc.func);

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcCombine from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcCombine& proc) {

    in >> proc.inTypes;
    in >> proc.outTypes;
    proc.func = static_cast<ProcCombine::Function>(in.read<uint8_t>());
    return in;
}

}

namespace rcProc {

/** Serializes ProcCranking to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcCranking& proc) {

    out << 'C' << 'R';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.types;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcCranking from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcCranking& proc) {

    in >> proc.types;
    return in;
}

}

namespace rcProc {

/** Serializes ProcDelay to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcDelay& proc) {

    out << 'd' << 'e';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.inType;
    out << proc.outType;
    out << proc.delayMs;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcDelay from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcDelay& proc) {

    in >> proc.inType;
    in >> proc.outType;
    in >> proc.delayMs;
    return in;
}

}

namespace rcProc {

/** Serializes ProcDirection to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcDirection& proc) {

    out << 'D' << 'I';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.inType;
    out << proc.outType;
    out << proc.speed;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcDirection from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcDirection& proc) {

    in >> proc.inType;
    in >> proc.outType;
    in >> proc.speed;
    return in;
}

}

namespace rcProc {

/** Serializes ProcExcavator to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcExcavator& proc) {

    out << 'E' << 'X';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later


    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcExcavator from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcExcavator& proc) {


    return in;
}

}

namespace rcProc {

/** Serializes ProcExpo to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcExpo& proc) {

    out << 'E' << 'x';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.inType;
    out << proc.outType;
    out << proc.b;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcExpo from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcExpo& proc) {

    in >> proc.inType;
    in >> proc.outType;
    in >> proc.b;
    return in;
}

}

namespace rcProc {

/** Serializes ProcFade to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcFade& proc) {

    out << 'F' << 'A';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.types;
    out << proc.fadeIn;
    out << proc.fadeOut;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcFade from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcFade& proc) {

    in >> proc.types;
    in >> proc.fadeIn;
    in >> proc.fadeOut;
    return in;
}

}

namespace rcProc {

/** Serializes ProcIndicator to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcIndicator& proc) {

    out << 'I' << 'N';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.types;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcIndicator from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcIndicator& proc) {

    in >> proc.types;
    return in;
}

}

namespace rcProc {

/** Serializes ProcMap to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcMap& proc) {

    out << 'M' << 'a';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.inType;
    out << proc.outType;
    out << proc.negative;
    out << proc.zero;
    out << proc.positive;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcMap from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcMap& proc) {

    in >> proc.inType;
    in >> proc.outType;
    in >> proc.negative;
    in >> proc.zero;
    in >> proc.positive;
    return in;
}

}

namespace rcProc {

/** Serializes ProcMisfire to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcMisfire& proc) {

    out << 'M' << 'i';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.outMisfireType;
    out << proc.misfireChance;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcMisfire from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcMisfire& proc) {

    in >> proc.outMisfireType;
    in >> proc.misfireChance;
    return in;
}

}

namespace rcProc {

/** Serializes ProcPeriodic to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcPeriodic& proc) {

    out << 'P' << 'E';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.freqType;
    out << proc.outType;
    out << proc.freqMultiplier;
    out << proc.offset;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcPeriodic from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcPeriodic& proc) {

    in >> proc.freqType;
    in >> proc.outType;
    in >> proc.freqMultiplier;
    in >> proc.offset;
    return in;
}

}

namespace rcProc {

/** Serializes ProcPower to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcPower& proc) {

    out << 'P' << 'O';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.outTypeLow;
    out << proc.outTypeEmpty;
    out << proc.lowLevel;
    out << proc.emptyLevel;
    out << proc.lowPercent;
    out << proc.emptyPercent;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcPower from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcPower& proc) {

    in >> proc.outTypeLow;
    in >> proc.outTypeEmpty;
    in >> proc.lowLevel;
    in >> proc.emptyLevel;
    in >> proc.lowPercent;
    in >> proc.emptyPercent;
    return in;
}

}

namespace rcProc {

/** Serializes ProcRandom to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcRandom& proc) {

    out << 'R' << 'A';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.type;
    out << proc.intervalMs;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcRandom from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcRandom& proc) {

    in >> proc.type;
    in >> proc.intervalMs;
    return in;
}

}

namespace rcProc {

/** Serializes ProcSequence to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcSequence& proc) {

    out << 'S' << 'E';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.inputType;
    out << proc.outputType;
    out << proc.onOffTimes;
    out << proc.sequenceDurationMs;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcSequence from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcSequence& proc) {

    in >> proc.inputType;
    in >> proc.outputType;
    in >> proc.onOffTimes;
    in >> proc.sequenceDurationMs;
    return in;
}

}

namespace rcProc {

/** Serializes ProcScenario to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcScenario& proc) {

    out << 'S' << 'C';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.inType;
    out << proc.outTypes1;
    out << proc.outTypes2;
    out << proc.outTypes3;
    out << proc.numScenarios;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcScenario from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcScenario& proc) {

    in >> proc.inType;
    in >> proc.outTypes1;
    in >> proc.outTypes2;
    in >> proc.outTypes3;
    in >> proc.numScenarios;
    return in;
}

}

namespace rcProc {

/** Serializes ProcSwitch to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcSwitch& proc) {

    out << 'S' << 'W';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.inType;
    out << proc.outTypesLong;
    out << proc.outTypesShort;
    out << proc.outTypesMomentary;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcSwitch from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcSwitch& proc) {

    in >> proc.inType;
    in >> proc.outTypesLong;
    in >> proc.outTypesShort;
    in >> proc.outTypesMomentary;
    return in;
}

}

namespace rcProc {

/** Serializes ProcThreshold to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcThreshold& proc) {

    out << 'T' << 'R';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.inType;
    out << proc.outType;
    out << proc.highThreshold;
    out << proc.lowThreshold;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcThreshold from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcThreshold& proc) {

    in >> proc.inType;
    in >> proc.outType;
    in >> proc.highThreshold;
    in >> proc.lowThreshold;
    return in;
}

}

namespace rcProc {

/** Serializes ProcXenon to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const ProcXenon& proc) {

    out << 'X' << 'E';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.types;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes ProcXenon from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    ProcXenon& proc) {

    in >> proc.types;
    return in;
}

}

// -- Engine


namespace rcEngine {

/** Serializes EngineReverse to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const EngineReverse& proc) {

    out << 'E' << 'R';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << static_cast<uint8_t>(proc.engineType);
    out << proc.reverseDelayMs;
    out << proc.crankingTimeMs;
    out << proc.offTimeMs;
    out << proc.massEngine;
    out << proc.massVehicle;
    out << proc.maxPower;
    out << proc.rpmMax;
    out << proc.idleManager;
    out << proc.wheelDiameter;
    out << proc.rpmShift;
    out << proc.gearDecouplingTime;
    out << proc.gearCouplingTime;
    out << proc.gearDoubleDeclutchTime;
    out << proc.fullGears;
    out << proc.brakePower;
    out << proc.resistance;
    out << proc.airResistance;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes EngineReverse from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    EngineReverse& proc) {

    proc.engineType = static_cast<EngineSimple::EngineType>(in.read<uint8_t>());
    in >> proc.reverseDelayMs;
    in >> proc.crankingTimeMs;
    in >> proc.offTimeMs;
    in >> proc.massEngine;
    in >> proc.massVehicle;
    in >> proc.maxPower;
    in >> proc.rpmMax;
    in >> proc.idleManager;
    in >> proc.wheelDiameter;
    in >> proc.rpmShift;
    in >> proc.gearDecouplingTime;
    in >> proc.gearCouplingTime;
    in >> proc.gearDoubleDeclutchTime;
    in >> proc.fullGears;
    in >> proc.brakePower;
    in >> proc.resistance;
    in >> proc.airResistance;
    return in;
}

}

namespace rcEngine {

/** Serializes EngineBrake to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const EngineBrake& proc) {

    out << 'E' << 'B';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << static_cast<uint8_t>(proc.engineType);
    out << proc.crankingTimeMs;
    out << proc.offTimeMs;
    out << proc.massEngine;
    out << proc.massVehicle;
    out << proc.maxPower;
    out << proc.rpmMax;
    out << proc.idleManager;
    out << proc.gears;
    out << proc.wheelDiameter;
    out << proc.rpmShift;
    out << proc.gearDecouplingTime;
    out << proc.gearCouplingTime;
    out << proc.gearDoubleDeclutchTime;
    out << proc.brakePower;
    out << proc.resistance;
    out << proc.airResistance;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes EngineBrake from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    EngineBrake& proc) {

    proc.engineType = static_cast<EngineSimple::EngineType>(in.read<uint8_t>());
    in >> proc.crankingTimeMs;
    in >> proc.offTimeMs;
    in >> proc.massEngine;
    in >> proc.massVehicle;
    in >> proc.maxPower;
    in >> proc.rpmMax;
    in >> proc.idleManager;
    in >> proc.gears;
    in >> proc.wheelDiameter;
    in >> proc.rpmShift;
    in >> proc.gearDecouplingTime;
    in >> proc.gearCouplingTime;
    in >> proc.gearDoubleDeclutchTime;
    in >> proc.brakePower;
    in >> proc.resistance;
    in >> proc.airResistance;
    return in;
}

}

namespace rcEngine {

/** Serializes EngineGear to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const EngineGear& proc) {

    out << 'E' << 'G';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << static_cast<uint8_t>(proc.engineType);
    out << proc.crankingTimeMs;
    out << proc.offTimeMs;
    out << proc.massEngine;
    out << proc.massVehicle;
    out << proc.maxPower;
    out << proc.rpmMax;
    out << proc.idleManager;
    out << proc.gears;
    out << proc.wheelDiameter;
    out << proc.rpmShift;
    out << proc.gearDecouplingTime;
    out << proc.gearCouplingTime;
    out << proc.gearDoubleDeclutchTime;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes EngineGear from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    EngineGear& proc) {

    proc.engineType = static_cast<EngineSimple::EngineType>(in.read<uint8_t>());
    in >> proc.crankingTimeMs;
    in >> proc.offTimeMs;
    in >> proc.massEngine;
    in >> proc.massVehicle;
    in >> proc.maxPower;
    in >> proc.rpmMax;
    in >> proc.idleManager;
    in >> proc.gears;
    in >> proc.wheelDiameter;
    in >> proc.rpmShift;
    in >> proc.gearDecouplingTime;
    in >> proc.gearCouplingTime;
    in >> proc.gearDoubleDeclutchTime;
    return in;
}

}

namespace rcEngine {

/** Serializes EngineSimple to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const EngineSimple& proc) {

    out << 'E' << 'S';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << static_cast<uint8_t>(proc.engineType);
    out << proc.crankingTimeMs;
    out << proc.massEngine;
    out << proc.maxPower;
    out << proc.rpmMax;
    out << proc.idleManager;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes EngineSimple from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    EngineSimple& proc) {

    proc.engineType = static_cast<EngineSimple::EngineType>(in.read<uint8_t>());
    in >> proc.crankingTimeMs;
    in >> proc.massEngine;
    in >> proc.maxPower;
    in >> proc.rpmMax;
    in >> proc.idleManager;
    return in;
}

}

// -- Audio


namespace rcAudio {

/** Serializes AudioDynamic to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const AudioDynamic& proc) {

    out << 'A' << 'd';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.speedType;
    out << proc.volumeType;
    out << proc.volume;
    out << proc.sample;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes AudioDynamic from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    AudioDynamic& proc) {

    in >> proc.speedType;
    in >> proc.volumeType;
    in >> proc.volume;
    in >> proc.sample;
    return in;
}

}

namespace rcAudio {

/** Serializes AudioLoop to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const AudioLoop& proc) {

    out << 'A' << 'L';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.triggerType;
    out << proc.volume;
    out << proc.loopBegin;
    out << proc.loopEnd;
    out << proc.sample;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes AudioLoop from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    AudioLoop& proc) {

    in >> proc.triggerType;
    in >> proc.volume;
    in >> proc.loopBegin;
    in >> proc.loopEnd;
    in >> proc.sample;
    return in;
}

}

namespace rcAudio {

/** Serializes AudioEngine to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const AudioEngine& proc) {

    out << 'A' << 'E';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.throttleType;
    out << proc.volume;
    out << proc.samples;
    out << proc.throttles;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes AudioEngine from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    AudioEngine& proc) {

    in >> proc.throttleType;
    in >> proc.volume;
    in >> proc.samples;
    in >> proc.throttles;
    return in;
}

}

namespace rcAudio {

/** Serializes AudioNoise to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const AudioNoise& proc) {

    out << 'A' << 'N';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.volumeType;
    out << proc.volume;
    out << static_cast<uint8_t>(proc.noiseType);
    out << proc.freq;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes AudioNoise from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    AudioNoise& proc) {

    in >> proc.volumeType;
    in >> proc.volume;
    proc.noiseType = static_cast<AudioNoise::NoiseType>(in.read<uint8_t>());
    in >> proc.freq;
    return in;
}

}

namespace rcAudio {

/** Serializes AudioSimple to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const AudioSimple& proc) {

    out << 'A' << 'S';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.triggerType;
    out << proc.volume;
    out << proc.sample;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes AudioSimple from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    AudioSimple& proc) {

    in >> proc.triggerType;
    in >> proc.volume;
    in >> proc.sample;
    return in;
}

}

namespace rcAudio {

/** Serializes AudioSteam to a byte stream. */
SimpleOutStream& operator<<(SimpleOutStream& out,
    const AudioSteam& proc) {

    out << 'A' << 's';
    auto startPos = out.tellg();
    out.write<uint8_t>(0u);  // we need to fill it out later
    out << proc.volume;
    out << proc.tone;
    out << proc.offset;
    out << proc.cylinderResistance;
    out << proc.exaustResistance;

    // fill out the actual length
    auto endPos = out.tellg();
    out.seekg(startPos);
    out.write<uint8_t>(endPos - startPos - 1);
    out.seekg(endPos);
    return out;
}

/** Deserializes AudioSteam from a byte stream. */
SimpleInStream& operator>>(SimpleInStream& in,
    AudioSteam& proc) {

    in >> proc.volume;
    in >> proc.tone;
    in >> proc.offset;
    in >> proc.cylinderResistance;
    in >> proc.exaustResistance;
    return in;
}

}

void ProcStorage::serializeProc(SimpleOutStream& out, const rcProc::Proc& proc) const {

    ProcId id('u', 'u');
    // note: the dynamic stuff only works if the procs
    //   are in the correct order in the definition file.
    //   in case of inheritance
    if (false) {  // just need an 'if' case
    // -- Input
    } else if (dynamic_cast<const rcInput::InputDemo*>(&proc)) {
        id = ProcId('D', 'E');        out << dynamic_cast<const rcInput::InputDemo&>(proc);
#ifdef ARDUINO
    } else if (dynamic_cast<const rcInput::InputAdc*>(&proc)) {
        id = ProcId('A', 'D');        out << dynamic_cast<const rcInput::InputAdc&>(proc);
#endif
#ifdef ARDUINO
    } else if (dynamic_cast<const rcInput::InputPin*>(&proc)) {
        id = ProcId('P', 'I');        out << dynamic_cast<const rcInput::InputPin&>(proc);
#endif
#ifdef ARDUINO
    } else if (dynamic_cast<const rcInput::InputPwm*>(&proc)) {
        id = ProcId('P', 'W');        out << dynamic_cast<const rcInput::InputPwm&>(proc);
#endif
#ifdef ARDUINO
    } else if (dynamic_cast<const rcInput::InputPpm*>(&proc)) {
        id = ProcId('P', 'P');        out << dynamic_cast<const rcInput::InputPpm&>(proc);
#endif
#ifdef ARDUINO
    } else if (dynamic_cast<const rcInput::InputSbus*>(&proc)) {
        id = ProcId('S', 'B');        out << dynamic_cast<const rcInput::InputSbus&>(proc);
#endif
#ifdef ARDUINO
    } else if (dynamic_cast<const rcInput::InputSrxl*>(&proc)) {
        id = ProcId('S', 'R');        out << dynamic_cast<const rcInput::InputSrxl&>(proc);
#endif
    // -- Output
#ifdef ARDUINO
    } else if (dynamic_cast<const rcOutput::OutputAudio*>(&proc)) {
        id = ProcId('O', 'A');        out << dynamic_cast<const rcOutput::OutputAudio&>(proc);
#endif
#ifdef ARDUINO
    } else if (dynamic_cast<const rcOutput::OutputLed*>(&proc)) {
        id = ProcId('O', 'L');        out << dynamic_cast<const rcOutput::OutputLed&>(proc);
#endif
#ifdef ARDUINO
    } else if (dynamic_cast<const rcOutput::OutputEsc*>(&proc)) {
        id = ProcId('O', 'E');        out << dynamic_cast<const rcOutput::OutputEsc&>(proc);
#endif
#ifdef ARDUINO
    } else if (dynamic_cast<const rcOutput::OutputPwm*>(&proc)) {
        id = ProcId('O', 'P');        out << dynamic_cast<const rcOutput::OutputPwm&>(proc);
#endif
    // -- General
    } else if (dynamic_cast<const rcProc::ProcGroup*>(&proc)) {
        id = ProcId('G', 'R');        out << dynamic_cast<const rcProc::ProcGroup&>(proc);
    } else if (dynamic_cast<const rcProc::ProcAuto*>(&proc)) {
        id = ProcId('A', 'U');        out << dynamic_cast<const rcProc::ProcAuto&>(proc);
    } else if (dynamic_cast<const rcProc::ProcCombine*>(&proc)) {
        id = ProcId('C', 'O');        out << dynamic_cast<const rcProc::ProcCombine&>(proc);
    } else if (dynamic_cast<const rcProc::ProcCranking*>(&proc)) {
        id = ProcId('C', 'R');        out << dynamic_cast<const rcProc::ProcCranking&>(proc);
    } else if (dynamic_cast<const rcProc::ProcDelay*>(&proc)) {
        id = ProcId('d', 'e');        out << dynamic_cast<const rcProc::ProcDelay&>(proc);
    } else if (dynamic_cast<const rcProc::ProcDirection*>(&proc)) {
        id = ProcId('D', 'I');        out << dynamic_cast<const rcProc::ProcDirection&>(proc);
    } else if (dynamic_cast<const rcProc::ProcExcavator*>(&proc)) {
        id = ProcId('E', 'X');        out << dynamic_cast<const rcProc::ProcExcavator&>(proc);
    } else if (dynamic_cast<const rcProc::ProcExpo*>(&proc)) {
        id = ProcId('E', 'x');        out << dynamic_cast<const rcProc::ProcExpo&>(proc);
    } else if (dynamic_cast<const rcProc::ProcFade*>(&proc)) {
        id = ProcId('F', 'A');        out << dynamic_cast<const rcProc::ProcFade&>(proc);
    } else if (dynamic_cast<const rcProc::ProcIndicator*>(&proc)) {
        id = ProcId('I', 'N');        out << dynamic_cast<const rcProc::ProcIndicator&>(proc);
    } else if (dynamic_cast<const rcProc::ProcMap*>(&proc)) {
        id = ProcId('M', 'a');        out << dynamic_cast<const rcProc::ProcMap&>(proc);
    } else if (dynamic_cast<const rcProc::ProcMisfire*>(&proc)) {
        id = ProcId('M', 'i');        out << dynamic_cast<const rcProc::ProcMisfire&>(proc);
    } else if (dynamic_cast<const rcProc::ProcPeriodic*>(&proc)) {
        id = ProcId('P', 'E');        out << dynamic_cast<const rcProc::ProcPeriodic&>(proc);
    } else if (dynamic_cast<const rcProc::ProcPower*>(&proc)) {
        id = ProcId('P', 'O');        out << dynamic_cast<const rcProc::ProcPower&>(proc);
    } else if (dynamic_cast<const rcProc::ProcRandom*>(&proc)) {
        id = ProcId('R', 'A');        out << dynamic_cast<const rcProc::ProcRandom&>(proc);
    } else if (dynamic_cast<const rcProc::ProcSequence*>(&proc)) {
        id = ProcId('S', 'E');        out << dynamic_cast<const rcProc::ProcSequence&>(proc);
    } else if (dynamic_cast<const rcProc::ProcScenario*>(&proc)) {
        id = ProcId('S', 'C');        out << dynamic_cast<const rcProc::ProcScenario&>(proc);
    } else if (dynamic_cast<const rcProc::ProcSwitch*>(&proc)) {
        id = ProcId('S', 'W');        out << dynamic_cast<const rcProc::ProcSwitch&>(proc);
    } else if (dynamic_cast<const rcProc::ProcThreshold*>(&proc)) {
        id = ProcId('T', 'R');        out << dynamic_cast<const rcProc::ProcThreshold&>(proc);
    } else if (dynamic_cast<const rcProc::ProcXenon*>(&proc)) {
        id = ProcId('X', 'E');        out << dynamic_cast<const rcProc::ProcXenon&>(proc);
    // -- Engine
    } else if (dynamic_cast<const rcEngine::EngineReverse*>(&proc)) {
        id = ProcId('E', 'R');        out << dynamic_cast<const rcEngine::EngineReverse&>(proc);
    } else if (dynamic_cast<const rcEngine::EngineBrake*>(&proc)) {
        id = ProcId('E', 'B');        out << dynamic_cast<const rcEngine::EngineBrake&>(proc);
    } else if (dynamic_cast<const rcEngine::EngineGear*>(&proc)) {
        id = ProcId('E', 'G');        out << dynamic_cast<const rcEngine::EngineGear&>(proc);
    } else if (dynamic_cast<const rcEngine::EngineSimple*>(&proc)) {
        id = ProcId('E', 'S');        out << dynamic_cast<const rcEngine::EngineSimple&>(proc);
    // -- Audio
    } else if (dynamic_cast<const rcAudio::AudioDynamic*>(&proc)) {
        id = ProcId('A', 'd');        out << dynamic_cast<const rcAudio::AudioDynamic&>(proc);
    } else if (dynamic_cast<const rcAudio::AudioLoop*>(&proc)) {
        id = ProcId('A', 'L');        out << dynamic_cast<const rcAudio::AudioLoop&>(proc);
    } else if (dynamic_cast<const rcAudio::AudioEngine*>(&proc)) {
        id = ProcId('A', 'E');        out << dynamic_cast<const rcAudio::AudioEngine&>(proc);
    } else if (dynamic_cast<const rcAudio::AudioNoise*>(&proc)) {
        id = ProcId('A', 'N');        out << dynamic_cast<const rcAudio::AudioNoise&>(proc);
    } else if (dynamic_cast<const rcAudio::AudioSimple*>(&proc)) {
        id = ProcId('A', 'S');        out << dynamic_cast<const rcAudio::AudioSimple&>(proc);
    } else if (dynamic_cast<const rcAudio::AudioSteam*>(&proc)) {
        id = ProcId('A', 's');        out << dynamic_cast<const rcAudio::AudioSteam&>(proc);
    }

    if (out.fail()) {
        printf("Error while writing proc ID %c%c.\n", id.c1, id.c2);
    }
}


rcProc::Proc* ProcStorage::deserializeProc(SimpleInStream& in) {

    const ProcId id{in.read<char>(), in.read<char>()};
    const uint8_t len = in.read<uint8_t>();
    const auto startPos = in.tellg();

    rcProc::Proc *proc = nullptr;
    if (false) {  // just need an 'if' case
    // -- Input
    } else if (id == ProcId{'D', 'E'}) {
        auto proc2 = new rcInput::InputDemo;
        in >> *proc2;
        proc = proc2;
#ifdef ARDUINO
    } else if (id == ProcId{'A', 'D'}) {
        auto proc2 = new rcInput::InputAdc;
        in >> *proc2;
        proc = proc2;
#endif
#ifdef ARDUINO
    } else if (id == ProcId{'P', 'I'}) {
        auto proc2 = new rcInput::InputPin;
        in >> *proc2;
        proc = proc2;
#endif
#ifdef ARDUINO
    } else if (id == ProcId{'P', 'W'}) {
        auto proc2 = new rcInput::InputPwm;
        in >> *proc2;
        proc = proc2;
#endif
#ifdef ARDUINO
    } else if (id == ProcId{'P', 'P'}) {
        auto proc2 = new rcInput::InputPpm;
        in >> *proc2;
        proc = proc2;
#endif
#ifdef ARDUINO
    } else if (id == ProcId{'S', 'B'}) {
        auto proc2 = new rcInput::InputSbus;
        in >> *proc2;
        proc = proc2;
#endif
#ifdef ARDUINO
    } else if (id == ProcId{'S', 'R'}) {
        auto proc2 = new rcInput::InputSrxl;
        in >> *proc2;
        proc = proc2;
#endif
    // -- Output
#ifdef ARDUINO
    } else if (id == ProcId{'O', 'A'}) {
        auto proc2 = new rcOutput::OutputAudio;
        in >> *proc2;
        proc = proc2;
#endif
#ifdef ARDUINO
    } else if (id == ProcId{'O', 'L'}) {
        auto proc2 = new rcOutput::OutputLed;
        in >> *proc2;
        proc = proc2;
#endif
#ifdef ARDUINO
    } else if (id == ProcId{'O', 'E'}) {
        auto proc2 = new rcOutput::OutputEsc;
        in >> *proc2;
        proc = proc2;
#endif
#ifdef ARDUINO
    } else if (id == ProcId{'O', 'P'}) {
        auto proc2 = new rcOutput::OutputPwm;
        in >> *proc2;
        proc = proc2;
#endif
    // -- General
    } else if (id == ProcId{'G', 'R'}) {
        auto proc2 = new rcProc::ProcGroup;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'A', 'U'}) {
        auto proc2 = new rcProc::ProcAuto;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'C', 'O'}) {
        auto proc2 = new rcProc::ProcCombine;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'C', 'R'}) {
        auto proc2 = new rcProc::ProcCranking;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'d', 'e'}) {
        auto proc2 = new rcProc::ProcDelay;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'D', 'I'}) {
        auto proc2 = new rcProc::ProcDirection;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'E', 'X'}) {
        auto proc2 = new rcProc::ProcExcavator;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'E', 'x'}) {
        auto proc2 = new rcProc::ProcExpo;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'F', 'A'}) {
        auto proc2 = new rcProc::ProcFade;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'I', 'N'}) {
        auto proc2 = new rcProc::ProcIndicator;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'M', 'a'}) {
        auto proc2 = new rcProc::ProcMap;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'M', 'i'}) {
        auto proc2 = new rcProc::ProcMisfire;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'P', 'E'}) {
        auto proc2 = new rcProc::ProcPeriodic;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'P', 'O'}) {
        auto proc2 = new rcProc::ProcPower;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'R', 'A'}) {
        auto proc2 = new rcProc::ProcRandom;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'S', 'E'}) {
        auto proc2 = new rcProc::ProcSequence;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'S', 'C'}) {
        auto proc2 = new rcProc::ProcScenario;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'S', 'W'}) {
        auto proc2 = new rcProc::ProcSwitch;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'T', 'R'}) {
        auto proc2 = new rcProc::ProcThreshold;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'X', 'E'}) {
        auto proc2 = new rcProc::ProcXenon;
        in >> *proc2;
        proc = proc2;
    // -- Engine
    } else if (id == ProcId{'E', 'R'}) {
        auto proc2 = new rcEngine::EngineReverse;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'E', 'B'}) {
        auto proc2 = new rcEngine::EngineBrake;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'E', 'G'}) {
        auto proc2 = new rcEngine::EngineGear;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'E', 'S'}) {
        auto proc2 = new rcEngine::EngineSimple;
        in >> *proc2;
        proc = proc2;
    // -- Audio
    } else if (id == ProcId{'A', 'd'}) {
        auto proc2 = new rcAudio::AudioDynamic;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'A', 'L'}) {
        auto proc2 = new rcAudio::AudioLoop;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'A', 'E'}) {
        auto proc2 = new rcAudio::AudioEngine;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'A', 'N'}) {
        auto proc2 = new rcAudio::AudioNoise;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'A', 'S'}) {
        auto proc2 = new rcAudio::AudioSimple;
        in >> *proc2;
        proc = proc2;
    } else if (id == ProcId{'A', 's'}) {
        auto proc2 = new rcAudio::AudioSteam;
        in >> *proc2;
        proc = proc2;
    } else {
        printf("Unknown proc ID %c%c.\n", id.c1, id.c2);
        in.seekg(startPos + len);
        proc = nullptr;
    }

    // in case we did end up reading a different amount of
    // bytes than expected
    const auto endPos = in.tellg();
    if (len != endPos - startPos) {
        printf("Actual length and received len for proc ID %c%c does not match.\n", id.c1, id.c2);
        printf("%d vs. %d.\n", static_cast<int>(endPos - startPos), static_cast<int>(len));
        in.seekg(startPos + len);
        delete proc;
        proc = nullptr;
    }
    if (in.fail()) {
        printf("Error while reading proc ID %c%c.\n", id.c1, id.c2);
        delete proc;
        proc = nullptr;
    }
    return proc;
}

