#!/usr/bin/env python3

# this script will convert the power_curves.svg to a number of curves.
#
# example usage:
#    python tools/convert_power_curves.py --cpp src/proc/power_curves.cpp --header src/proc/power_curves.h
#

import argparse
import datetime
import pathlib
import re
import xml.etree.ElementTree as ET


def output_cpp(power_graphs, out_file):
    """Outputs the cpp file with all the power curve types."""

    def curve_points(points):
        """Converts a list of points to something like this:

        ["rcProc::CurvePoint{1.0f, 0.5f}", "rcProc::CurvePoint{2.0f, 4.0f}"]

        Points are scaled (by 100 and the y-axis is flipped)
        """
        return [
                f"        rcProc::CurvePoint{{{(float(point[0]) / 100.0):.2f}f, {((100.0 - float(point[1])) / 100.0):.2f}f}}"
            for point in points
        ]

    def definition(graph):
        """Converts an entry from the power_graphs list to a definition suitable
        for a cpp file

        :param graph: an entry like this:
            {"id": "id", "title": "title", "points": ["x,y", ...]}
        """
        return f"""
const rcProc::Curve<{len(graph["points"])}> powerCurve{graph["id"]}{{
    .points={{
{",\n".join(curve_points(graph["points"]))}
    }}}};
"""

    print(
        f"""/** Power curve definitions.
 *
 * This file is auto generated by serialization_tool.py
 * {str(datetime.date.today())}
 *
 * Do not modify.
 *
 * @file
 */

#include "power_curves.h"

namespace rcEngine {{

{"\n".join([definition(graph) for graph in power_graphs])}

}} // namespace

""",
        file=out_file,
    )


def output_h(power_graphs, out_file):
    """Outputs the header with all the power curve types."""

    def declaration(graph):
        """Converts an entry from the power_graphs list to a definition suitable
        for a header file

        :param graph: an entry like this:
            {"id": "id", "title": "title", "points": ["x,y", ...]}
        """
        return f"""/** Power curve definition for {graph["title"]}.
 *
 * Used by ProcSimpleEngine.
 */
extern const rcProc::Curve<{len(graph["points"])}> powerCurve{graph["id"]};
"""

    print(
        f"""/** Power curve declarations.
 *
 * This file is auto generated by serialization_tool.py
 * {str(datetime.date.today())}
 *
 * Do not modify.
 *
 * It contains the power curves for different engine types
 * created from power.svg.
 *
 * The power are scaled to max RPM and max power.
 *
 * @file
 */

#ifndef _RC_POWER_CURVES_H_
#define _RC_POWER_CURVES_H_

#include "curve.h"

namespace rcEngine {{

{"\n".join([declaration(graph) for graph in power_graphs])}

}} // namespace

#endif // _RC_POWER_CURVES_H_
""",
        file=out_file,
    )


# --- main code

parser = argparse.ArgumentParser(
    prog="convert_power_curves",
    description="Tool for converting the power curves svg file into power curves for the simple_engine",
    epilog="This tool will only work with inkscape generated files. It's not a generic svg parser.",
)

parser.add_argument(
    "--svg",
    "-s",
    type=argparse.FileType("r"),
    help="Input power svg",
    default=str(pathlib.Path(__file__).parent.parent / "config" /  "power_curves.svg"),
)
parser.add_argument(
    "--header",
    type=argparse.FileType("w"),
    help="Create .h file containing the power definitions.",
)
parser.add_argument(
    "--cpp",
    "-c",
    type=argparse.FileType("w"),
    help="Create .cpp file power curves.",
)

args = parser.parse_args()

# parse the svg file.
# we are only interested in the paths
# result will look like this:
#
# [{"id": "id", "title": "title", "points": ["x,y", ...]}]
power_graphs = []

re_numbers = re.compile(r"\s([-+]?\d*\.*\d+,\s*[-+]?\d*\.*\d+)")

tree = ET.parse(args.svg)
el_root = tree.getroot()

# import pdb; pdb.set_trace()

for el_path in el_root.iter("{http://www.w3.org/2000/svg}path"):

    txt_title = "unnamed"
    for el_title in el_path.iter("{http://www.w3.org/2000/svg}title"):
        txt_title = el_title.text

    txt_id = el_path.get("id", "noId")

    txt_points = el_path.get("d", "")
    numbers = re_numbers.findall(txt_points)
    numbers = [number.split(",") for number in numbers]  # split them in two

    # check if it's relative coordinates
    if txt_points[0] == "m":
        index = 1;
        pos_x = float(numbers[0][0])
        pos_y = float(numbers[0][1])
        while index < len(numbers):
            numbers[index][0] = float(numbers[index][0]) + pos_x
            numbers[index][1] = float(numbers[index][1]) + pos_y
            pos_x = numbers[index][0]
            pos_y = numbers[index][1]
            index += 1

    # check if the x-coordinates are reversed
    if len(numbers) > 1 and float(numbers[0][0]) > float(numbers[1][0]):
        numbers = list(reversed(numbers))

    power_graphs.append({"id": txt_id, "title": txt_title, "points": numbers})

if args.cpp:
    output_cpp(power_graphs, args.cpp)
if args.header:
    output_h(power_graphs, args.header)
