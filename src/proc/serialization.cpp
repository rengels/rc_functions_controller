/** Serialization code for the proc classes.
 *
 * This file is auto generated by serialization_tool.py
 * 2024-10-02
 *
 * Do not modify.
 *
 * @file
 */

#include "proc.h"
#include "simple_byte_stream.h"

#include "input_demo.h"
#include "proc_auto.h"
#include "proc_beacon_us.h"
#include "proc_cranking.h"
#include "proc_engine_simple.h"
#include "proc_excavator.h"
#include "proc_fade.h"
#include "proc_direction.h"
#include "proc_indicator.h"
#include "proc_math.h"
#include "proc_xenon.h"

using namespace rcSignals;
using namespace rcInput;


namespace rcProc {

/** Identifier for the different proc types when serializing
 *  and deserializing.
 */
enum class rcProc::ProcType : uint8_t {
    INVALID = 0u,
    // -- Input
    INPUT_DEMO = 1u,  // Creates signals without outside input.
    // -- General
    PROC_AUTO = 10u,  // Creates many signals, using sensible rules, e.g. direction indicators from steering.
    PROC_BEACON_US = 11u,  // Creates a blinking effect like US-style warning beacon.
    PROC_CRANKING = 12u,  // Dims signals while the cranking signal is active
    PROC_ENGINE_SIMPLE = 13u,  // Simulates an engine without gear
    PROC_EXCAVATOR = 14u,  // Creates many excavator related signals e.g. hydraulic flow.
    PROC_FADE = 15u,  // Fades signals in and out. Can be used to slow down signals or for effects, e.g. indacent light bulb effect.
    PROC_DIRECTION = 16u,  // The output signal is 'moved' by the input signals.
    PROC_INDICATOR = 17u,  // Creates a synchronized blinking effect.
    PROC_MATH = 18u,  // Does several operations on the input signals.
    PROC_XENON = 19u,  // Xenon light flash effect.
};

} // namespace


namespace rcProc {

rcProc::Proc* createProc(rcProc::ProcType type) {
    rcProc::Proc *proc = nullptr;
    switch (type) {
    case rcProc::ProcType::INPUT_DEMO:
        proc = new InputDemo;
        break;
    case rcProc::ProcType::PROC_AUTO:
        proc = new ProcAuto;
        break;
    case rcProc::ProcType::PROC_BEACON_US:
        proc = new ProcBeaconUs;
        break;
    case rcProc::ProcType::PROC_CRANKING:
        proc = new ProcCranking;
        break;
    case rcProc::ProcType::PROC_ENGINE_SIMPLE:
        proc = new ProcEngineSimple;
        break;
    case rcProc::ProcType::PROC_EXCAVATOR:
        proc = new ProcExcavator;
        break;
    case rcProc::ProcType::PROC_FADE:
        proc = new ProcFade;
        break;
    case rcProc::ProcType::PROC_DIRECTION:
        proc = new ProcDirection;
        break;
    case rcProc::ProcType::PROC_INDICATOR:
        proc = new ProcIndicator;
        break;
    case rcProc::ProcType::PROC_MATH:
        proc = new ProcMath;
        break;
    case rcProc::ProcType::PROC_XENON:
        proc = new ProcXenon;
        break;
    default:
        proc = nullptr;
    }
    return proc;
}

} // namespace


    // -- Input
    

rcProc::ProcType rcInput::InputDemo::type() const {
    return rcProc::ProcType::INPUT_DEMO;
}

void rcInput::InputDemo::serialize(rcSignals::SimpleOutStream* const stream) {

}

void rcInput::InputDemo::deserialize(rcSignals::SimpleInStream* const stream) {

}


    // -- General
    

rcProc::ProcType rcProc::ProcAuto::type() const {
    return rcProc::ProcType::PROC_AUTO;
}

void rcProc::ProcAuto::serialize(rcSignals::SimpleOutStream* const stream) {

}

void rcProc::ProcAuto::deserialize(rcSignals::SimpleInStream* const stream) {

}


rcProc::ProcType rcProc::ProcBeaconUs::type() const {
    return rcProc::ProcType::PROC_BEACON_US;
}

void rcProc::ProcBeaconUs::serialize(rcSignals::SimpleOutStream* const stream) {
    stream->writeSignalTypes(types, 4);
}

void rcProc::ProcBeaconUs::deserialize(rcSignals::SimpleInStream* const stream) {
    stream->readSignalTypes(types, 4);
}


rcProc::ProcType rcProc::ProcCranking::type() const {
    return rcProc::ProcType::PROC_CRANKING;
}

void rcProc::ProcCranking::serialize(rcSignals::SimpleOutStream* const stream) {
    stream->writeSignalTypes(types, 4);
}

void rcProc::ProcCranking::deserialize(rcSignals::SimpleInStream* const stream) {
    stream->readSignalTypes(types, 4);
}


rcProc::ProcType rcProc::ProcEngineSimple::type() const {
    return rcProc::ProcType::PROC_ENGINE_SIMPLE;
}

void rcProc::ProcEngineSimple::serialize(rcSignals::SimpleOutStream* const stream) {

}

void rcProc::ProcEngineSimple::deserialize(rcSignals::SimpleInStream* const stream) {

}


rcProc::ProcType rcProc::ProcExcavator::type() const {
    return rcProc::ProcType::PROC_EXCAVATOR;
}

void rcProc::ProcExcavator::serialize(rcSignals::SimpleOutStream* const stream) {

}

void rcProc::ProcExcavator::deserialize(rcSignals::SimpleInStream* const stream) {

}


rcProc::ProcType rcProc::ProcFade::type() const {
    return rcProc::ProcType::PROC_FADE;
}

void rcProc::ProcFade::serialize(rcSignals::SimpleOutStream* const stream) {
    stream->writeSignalTypes(types, 4);
    stream->writeRcSignal(fadeIn);
    stream->writeRcSignal(fadeOut);
}

void rcProc::ProcFade::deserialize(rcSignals::SimpleInStream* const stream) {
    stream->readSignalTypes(types, 4);
    fadeIn = stream->readRcSignal();
    fadeOut = stream->readRcSignal();
}


rcProc::ProcType rcProc::ProcDirection::type() const {
    return rcProc::ProcType::PROC_DIRECTION;
}

void rcProc::ProcDirection::serialize(rcSignals::SimpleOutStream* const stream) {
    stream->writeSignalTypes(&inType, 1);
    stream->writeRcSignal(speed);
}

void rcProc::ProcDirection::deserialize(rcSignals::SimpleInStream* const stream) {
    stream->readSignalTypes(&inType, 1);
    speed = stream->readRcSignal();
}


rcProc::ProcType rcProc::ProcIndicator::type() const {
    return rcProc::ProcType::PROC_INDICATOR;
}

void rcProc::ProcIndicator::serialize(rcSignals::SimpleOutStream* const stream) {
    stream->writeSignalTypes(types, 4);
}

void rcProc::ProcIndicator::deserialize(rcSignals::SimpleInStream* const stream) {
    stream->readSignalTypes(types, 4);
}


rcProc::ProcType rcProc::ProcMath::type() const {
    return rcProc::ProcType::PROC_MATH;
}

void rcProc::ProcMath::serialize(rcSignals::SimpleOutStream* const stream) {
    stream->writeSignalTypes(inTypes, 2);
    stream->writeSignalTypes(outTypes, 2);
    stream->writeUint8(static_cast<uint8_t>(func));
}

void rcProc::ProcMath::deserialize(rcSignals::SimpleInStream* const stream) {
    stream->readSignalTypes(inTypes, 2);
    stream->readSignalTypes(outTypes, 2);
    func = static_cast<ProcMath::Function>(stream->readUint8());
}


rcProc::ProcType rcProc::ProcXenon::type() const {
    return rcProc::ProcType::PROC_XENON;
}

void rcProc::ProcXenon::serialize(rcSignals::SimpleOutStream* const stream) {
    stream->writeSignalTypes(types, 4);
}

void rcProc::ProcXenon::deserialize(rcSignals::SimpleInStream* const stream) {
    stream->readSignalTypes(types, 4);
}

