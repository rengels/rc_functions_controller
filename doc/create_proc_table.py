#!/usr/bin/env python3

# This script will create markdown pages with tables
# containing proc_modules and signals for documentation.
#
# - proc_modules
# - signals
#
# example usage: docu_table_tool.py --procs procs_config.json --procs-table procs_table.md
#

import argparse
import datetime
import json
import pathlib

def output_procs_table(defs_proc, out_file):
    """Outputs a markdown table with an overview of all the *procs* into the out file.
    """

    def calc_types_string(types):
        """Returns a string like this "4 + 3" for all the types"""
        if (types is None) or (len(types) == 0):
            return "0"
        else:
            return " + ".join([str(type.get("num", 0)) for type in types])

    # get all proc filenames for our includes
    proc_rows = (
        f"| {proc["id"]} | {proc['name']} | {proc['filename']}.h | {calc_types_string(proc["types"])} | {proc['description']} | "
        for proc in defs_proc
        if "name" in proc
    )

    print(
        f"""
<! This file is auto generated by create_procs_table.py>
<! {str(datetime.date.today())}>

<! Do not modify.>

@page page_procs Procs

# Procs overview

Proc classes implement the rcProc::Proc interface
process the signals in one way or another.

The following table shows all available procs:

| Internal ID | Name | file | configurable signals | description |
|-------------|------|------|----------------------|-------------|
{'\n'.join(proc_rows)}

""",
        file=out_file,
    )

def output_signals_table(defs_signals, out_file):
    """Outputs the signal types header containing SignalTypes enum into the out file."""

    def signal_type_line(signal):
        """Converts an entry in def_signals to a line for the header file

        :param signal: A signal structure from the def_signals.json file.
          A dict containing optional *name*, *number* and *description*.
        """
        ret = ""
        if "name" in signal and "number" in signal:
            ret += "| " + str(signal["number"])
            ret += " | " + signal["name"]
            if "description" in signal:
                ret += " | " + signal["description"]
            else:
                ret += " | "
            return ret + " |"
        else:
            return None

    print(
        f"""
<! This file is auto generated by create_procs_table.py>
<! {str(datetime.date.today())}>

<! Do not modify.>

@page page_signals Signals

# Signals overview

The follow table lists all signals used as main communication
channel throughout the project.

| Internal ID | Name | description |
|-------------|------|-------------|
{"\n".join([signal_type_line(signal) for signal in defs_signals if "name" in signal])}
""",
        file=out_file,
    )


# --- main code

parser = argparse.ArgumentParser(
    prog="docu_table_tool",
    description="Tool for creating markdown pages with tables for documentation. The pages contain a nice tables with all the signals and procs.",
    epilog="Have fun",
)

parser.add_argument(
    "--procs",
    "-p",
    type=argparse.FileType("r"),
    help="Proc definition file",
    default=str(pathlib.Path(__file__).parent.parent / "src" / "config" / "procs_config.json"),
)
parser.add_argument(
    "--signals",
    "-s",
    type=argparse.FileType("r"),
    help="Signals definition file",
    default=str(pathlib.Path(__file__).parent.parent / "src" / "config" / "signals_config.json"),
)
parser.add_argument(
    "--procs-table",
    type=argparse.FileType("w"),
    help="Create the proc .md page.",
)
parser.add_argument(
    "--signals-table",
    type=argparse.FileType("w"),
    help="Create the signals .md page.",
)

args = parser.parse_args()

defs_proc = json.load(args.procs)

defs_signals = json.load(args.signals)

# create a mapping signal name vs number
signals_mapping = {}
number = 0
for signal in defs_signals:
    if "number" in signal:
        number = signal["number"]
    if "name" in signal:  # jump over descriptions
        signals_mapping[signal["name"]] = number
        signal["number"] = number
        number += 1

if args.procs_table:
    output_procs_table(defs_proc, args.procs_table)
if args.signals_table:
    output_signals_table(defs_signals, args.signals_table)
